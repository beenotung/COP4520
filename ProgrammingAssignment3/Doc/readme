\subsecton( Skip list)
The skip list is a multi-level linked-list in which the same node typically appears on multiple level. Each node is inserted on the bottom-level and has a firfty percent chance of moving up to each subsequent level. A search begins on the top-left corner of the skiplist and moves right until a greater-than-desired value is found, at which point it moves down. This process is repeated until either a matching node is found or the bottom has been reached and the next value is greater than desired. The skip list alone achieves an average O(log n) time complexity, and its performance can be increased with the use of an x-fast trie which finds the matching top-level node in O(log log M). This is especially useful when the skip list is shallow. 


\subsubsection{Node:}
struct slNode contains the following members:
(uint32_t) key holds the value that is being saved. The maximum value is set by the MAXKEY macro, which can scale up to 2^32 and is currently set to 65536 (2^16).
(atomic_uintptr_t) * next is a pointer to a pointer type pointing to the next slNode. It acts as a double pointer but instead points to an integer type instead of a direct pointer type, because the last bit is used as a flag to signal that the pointee is going to be removed soon, therefore the pointer would be misaligned if it were to be used with no additional processong (a bitwise operation). There are as many next "pointers" as there are levels in the skiplist, which is an arbitrary number usually between four and sixteen.
it cannot be used directly as a pointer as it can be misaligned.
struct slNode_ * previous is a single pointer pointing to the previous node. It is used only on the top-level of the skiplist and remains null on nodes which do not make it to the top. Its purpose is to function as the xtrie's bottom findpredecessor function.
uint8_t stopflag is a single flag which announces that a node is in the process of being deleted. It is easy to set because each node only has one stopflag, but inconvenient to check, because these checks are performed through the compare-and-exchange using the next pointers.

	
	
\subsubsection{Search:}
	A search begins at the top of the top-left of the skip list (root) and proceeds to the right until either a node containing the MAXVALUE key, or a key higher than the desired one is found. At this point, the search moves to the level below, which contains approximately twice as many keys. This process is repeated until the desired key is found, or the bottom is reached and the next key is higher than desired one (not found). This method allows us to skip through most keys and results in a O(log u) search time, which remains relatively fast regardless of the amount of data stored in the structure as long as an appropriately high enough number of levels is chosen. The author suggest using 4 levels (log log u) but we found that performance is best using at least 16 when the skip list is used independently. The path looks like a set of increasingly uneven stairs going from the top-left to the bottom-right.

We use a chaosmeter to achieve concurrency. Whenever the next node cannot be reached because it has been deleted during traversal, a new next node is fetched and the chaosmeter is incremented. When the chaosmeter reaches MAXCHAOS (typically 10), the current node is reset to head (which can either be the skip list's head or the closest top-level predecessor obtained from the x-fast trie) so that the search can resume.
	
\subsubsection{Insert:}
	Inserting a key into the skip list starts out the same way as a search, but the last node for every level is saved before descending. When the bottom is reached and the correct location is found, a new node is created, its next pointer is set to the previous node’s next pointer, and the previous node’s next pointer is set to the new node. A “coin” is tossed to determine whether the node should be inserted into the next level up, and this process is repeated on every level (until the coin returns a negative value) using the list of nodes saved while descending the list. This implementation uses a single random number (rand()) to generate all the necessary coin tosses (up to 32) using each of the single random number’s bits as an individual coin toss. The insert function returns a flag if the top-level is reached, in which case the value is to be added into the x-fast trie as well.

In order to achieve better concurrency, we implemented an experimental insertion method which can be activated by setting the slMERGEDUPLICATES macro to 1 in testcase1.h (or in skiplist.h if testcase1.h is not included).
A standard skip list traverses the entire structure, tracing the path and finding a potential duplicate. The insert is aborted if the key was found, otherwise the path is traced back. This creates a considerable time gap between the initial saved traversal and the actual insertion, and nodes often end up being modified by the time the insertion takes place.
The slMERGEDUPLICATES approach begins insertion as soon as the first insertion level has been reached, and abort only if the key already exists on a higher level (prior to insertion). If the key being inserted is found somewhere down the structure, the new node takes its pointers and eventually deletes the old one. This approach greatly reduces the number of collisions, and ends up moving the more frequently used nodes up for faster retrieval. The downsides are a longer insertion time (which is somewhat insignificant considering most real-world operations are find) and a higher programming complexity (insert now includes a deletion). This approach has been implemented in our skip list, but it is currently not fully functional (sometimes causes segmentation faults), therefore it was disabled by default and replaced by a call to slFind which detects any potential duplicates and abort prior to slInsert execution.

Overall concurrency is achieved through the use of bit-stealing and CAS instructions. While the author of the skiptrie advocates the use of DCSS (double-compare-single-swap) instructions, those do not exist in the real world. Insertions use the CAS ("atomic_compare_exchange") instructions to check a pointer and simultaneously swap it if it matches another. As always, we have a current node which acts as the target's predecessor and a next node which is its direct successor, such that current < newkey < next and current->next. We want to set the current node's next pointer to the new node and the new node's next pointer to the next (current->new->next), preferably without linking to a soon-to-be-deleted node. We begin by setting the new node's next pointer to the next node, then we perform a CAS operation using current->next as the target object to be compared, nextnode as the expected object, and newnode as the desired value to be written as the target if the comparaison is successful. The operation will fail if the nodes have changed or if the current node has been flagged (through the current->next pointer, causing a mismatch with nextnode pointer which is never flagged). Because we are using a compare-and-exchange (CAS) operation when we really need a (nonexistant) compare-and-set, the expected variable is modified whenever the CAS operation fails. We use a bitwise operation to remove the flag from nextnode when the CAS fails. This whole process is repeated for each insertion level.

If the CAS operation fails or if a nextNode is removed from under our feet, we jump back to the beginning of the current level insertion, fetch the next node, and increase the chaosmeter. The current node is reset (using either the head or the x-fast trie find predecessor function) after MAXCHAOS failures, and the search goes on without ever reaching complete failure.

 

\subsubsection{Remove:}
	To remove from the skip list, we perform a search for the undesirable key. Once the key is found, the previous node’s next pointer is set to the undesirable node’s next pointer, and this process is repeated on for every level below. Once the pointers have been appropriately set, the memory is freed using the free() function on both the node itself and its dynamically allocated next pointer. Remove places a stolen bit on each of a soon-to-be-deleted node's next pointer in order to announce impending deletion, then use a CAS operation similar to that used in insert. 
	
slRemove finds the target and marks it as a new slNode pointer. It then performs an atomic_fetch_or on the current target->next pointer (increasing the chaosmeter in case of failure), and performs a CAS operation with curNode->next as the comparee/recipient, target->next as the compared, and target->next (unmarked) as the successful outcome. This sets the current node's next pointer to target's successor iff target is current node's successor. In case of failure, we remove the unintentionally stolen bit from the local target pointer (and goto the beginning of the current level's remove function after increasing the chaos meter).
	
Multiple remove operations sometimes conflict with each other. As usual, the chaosmeter keeps track of all undesirable behavior and removes any potential contention issue. When maximum chaos is reached (after MAXCHAOS, typically ten failures), the current node's pointer is reset as in every other functions. If the issues persist, the hopelesness state occurs after MAXCHAOS maximum chaos. The hopelesness state removes the current level's stolen bit, typically freeing any blocking issue. It was determined that freeing all levels' stolen bits made little to no difference, therefore the next step which occurs after MAXCHAOS cubed, is called acceptance. Acceptance unmarks all stolen bits from the target node, and gives up. Acceptance is typically reached between zero and four times on four million operations (fifty percent or two millions of which are remove) spread over eight threads, it has shown to remove any potential issues and it only occurs during a delete operation (arguably the least critical one). 

\subsection{X-fast trie link:}	
When a node is inserted into a four-level skip list, it has a 1/16 (1/2^4) probability of being inserted onto the top-level. This makes traditional lateral traversal extremely costly. The x-fast trie can efficiently jump to the appropriate top-level node, saving heaps of time on dense and shallow skip lists (eg: four-levels where approximately 1/16 or 1/2^16 of all nodes would have to be traversed through the top-level). This benefit is largely mitigated on deeper skip lists, whose find function can quickly traverse the sparsely populated top-level (eg: sixteen-levels where only 1/2^16 or 1/65536 of all nodes would have to be traversed).
